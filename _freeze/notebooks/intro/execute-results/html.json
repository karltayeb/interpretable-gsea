{
  "hash": "82ff6691f10717bad26d30d14e86e8d1",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute:\n  eval: true\n---\n\n\n\n\n\n\n\n\n# Introduction\n\n### A quick look at using the `gibss` python package\n\nWe develop a fast and extensible implementation of GIBSS in python utilizing JAX for autodifferentiation and fast JIT compiled code. The goal will be to have the `gseasusie` software package automatically set up a python environment for `R` users, and make calls to the underlying python library via `reticulate`.\n\nChoose a python environment for `reticulate` to use\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\nuse_virtualenv('gibss')\n```\n:::\n\n\n\n\n\n\n\n\n\nHere is a quick example showing how to use `gibss`\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom gibss.logisticprofile import logistic_ser_hermite, logistic_susie, fit_null\nimport numpy as np\n\n# simulate some data, 100 variables, 10k observations\nX = np.random.normal(size=(100, 10000))\nx = X[0]\ny = np.random.binomial(1, p = np.exp(x-1)/(1 + np.exp(x-1))).astype(float)\ncoef_init = np.zeros((X.shape[0], 2))\n\n\n# fit a null model\nnullfit = fit_null(y, 0.)\n\n# fit an SER\nserfit = logistic_ser_hermite(coef_init, X, y, 0.0, 1.0, 1)\n\n# fit SuSiE via GIBSS\nfit = logistic_susie(X, y, L=5, method='hermite', serkwargs=dict(m=1, prior_variance=1.0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0%|          | 0/9 [00:00<?, ?it/s]Iteration 0\n\n\n0it [00:00, ?it/s]\u001b[A\n\n                  \u001b[AMax diffs: [4.5299530e-05 4.7007729e-03 2.0518620e-03 4.3146126e-04 8.5080508e-04]\n\n 11%|#1        | 1/9 [00:00<00:04,  1.66it/s]Iteration 1\n\n\n0it [00:00, ?it/s]\u001b[A\n\n                  \u001b[AMax diffs: [7.8678131e-06 1.6043941e-04 1.0394445e-04 1.2211176e-04 9.6947188e-06]\n\n 11%|#1        | 1/9 [00:01<00:10,  1.28s/it]\nConverged: True at tolerance 0.001\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### GSEA example\n\n`gseasusie::load_gene_sets` is a helper function for getting gene sets from different sources in a unified format. It gets curated pathways from the `WebGestaltR`, MSigDb pathways from `msigdbr`.\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#devtools::install_github('karltayeb/gseasusie')\nc2 <- gseasusie:::load_msigdb_geneset_x('C2')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nloading gene set from msigdbr: C2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWe get a flat list where each row is a `(gene, gene set)` pair.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(c2$geneSet)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  geneSet   gene\n1   M1423  79026\n2   M1423    214\n3   M1423  91369\n4   M1423   8289\n5   M1423    594\n6   M1423 146556\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWe also have access to a human readable description of each gene-set\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(c2$geneSetDes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  geneSet gs_cat gs_subcat\n1   M1423     C2       CGP\n2   M1458     C2       CGP\n3   M1481     C2       CGP\n4   M1439     C2       CGP\n5   M2509     C2       CGP\n6   M2096     C2       CGP\n                                                                                                                                                                                             description\n1                                                                                                        Genes down-regulated in AtT20 cells (pituitary cancer) after  treatment with LIF [GeneID=3976].\n2                                                                                                          Genes up-regulated in AtT20 cells (pituitary cancer) after  treatment with LIF [GeneID=3976].\n3                                                                                                           Genes down-regulated in GH3 cells (pituitary cancer) after treatment with LIF [GeneID=3976].\n4                                                                                                             Genes up-regulated in GH3 cells (pituitary cancer) after treatment with LIF [GeneID=3976].\n5                                                                                                   Major ELAVL4 [GeneID=1996] associated mRNAs encoding proteins with functions in neuronal physiology.\n6 Genes down-regulated in the RCC4 cells (renal cell carcinoma, RCC) expressing VHL [GeneID=7428] mutants Type 1 and 2B (associated with RCC) but not those of Type 2A and 2C (not associated with RCC).\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nFinally, we have a sparse binary matrix encoding gene set membership. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(c2$X)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21720  5593\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nTo perform gene set enrichment analysis using logistic SuSiE we will writer a helper function in python. `gibss` interface is designed to be modular and composable to streamline the development of\nnew models, but it is not designed to have a particularly user friendly interface.\n\nWe run logistic SuSiE with a fixed prior variance $\\sigma^2=1$.\nWe use `logisticprofile` module, where we perform logistic regression, maximizing over the intercept for each variable. \nWe compute the MAP estimate for each variable, and approximate the Bayes factor using the Laplace-MAP approximation, (as opposed to the Laplace-MLE) approximation. We make this choice because it is not uncommon to have gene sets that are either completely observed, or completely unobserved in the gene list. In this case the MLE does not exist and MLE based approximations can have unweildly behavior. The Laplace approximation at the MAP is equivalent to Gauss-Hermite quadrature (with a particular reparameterization) and $m=1$ quadrature points.\n\nNote that even with the optimized implementation things can be quite slow. \nOne strategy we are thinking about implementing is pre-screening with a score-based approximation to the Bayes factor. The idea is that we can quickly compute rough approximations to the Bayes factor using a score based approximation. For the promising results, we can follow up with a more fine grain calculation of the Bayes factor.\n\nMy proposal for the estimation of the prior variance is to compute that MAP along a grid of prior variances, and interplate point estimates/Bayes factor approximations between these. This should not be much more expensive to compute because we can use the estimates from a fit at one setting of the prior variance to initialize the optimization at the next setting of the prior variance. This \"warm start\" initialization has the advantage of introducing computational stability as well. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass\nimport numpy as np\nfrom gibss.logisticprofile import logistic_susie, logistic_ser_hermite\n\nnp.random.seed(1)\nX = r.c2['X'].toarray().T\nbeta0 = -3\nbeta = np.zeros(X.shape[0])\nbeta[np.random.choice(beta.size, 5, replace=False)] = 2.\nlogit = beta @ X + beta0\ny = np.random.binomial(1, 1/(1 + np.exp(-logit)))\n\n\n@dataclass\nclass GSEARes:\n  alpha: np.ndarray\n  effects: np.ndarray\n  log_bfs: np.ndarray\n  \nget_alpha = lambda fit: np.array([c.alpha for c in fit.components])\nget_beta = lambda fit: np.array([c.fits.beta for c in fit.components])\nget_lbf = lambda fit: np.array([c.lbf_ser for c in fit.components])\n\ndef gsea(X, y, L=5, prior_variance = 1, maxiter = 10, tol=1e-3):\n  # TODO: check types\n  fit = logistic_susie(\n    X.astype(float), y.astype(float),\n    L=L, method='hermite',\n    serkwargs=dict(m=1, prior_variance=1.0)\n  )\n  return GSEARes(get_alpha(fit), get_beta(fit), get_lbf(fit))\n\n# fit SER for marginal analysis\nserfit = logistic_ser_hermite(\n  coef_init = np.zeros((X.shape[0], 2)), \n  X = X.astype(float), \n  y = y.astype(float), \n  offset = 0., \n  prior_variance = 1.,\n  m = 1\n)\n# extract relevant info from SER\nmarginal_results = dict(\n  lbf=np.array(serfit.fits.lbf),\n  effect=np.array(serfit.fits.beta)\n)\n\ngseafit = gsea(X, y, L=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0%|          | 0/9 [00:00<?, ?it/s]Iteration 0\n\n\n0it [00:00, ?it/s]\u001b[A\n\n2it [00:00, 10.85it/s]\u001b[A\n\n4it [00:00, 11.13it/s]\u001b[A\n\n4it [00:20, 11.13it/s]\u001b[A\n\n5it [00:32,  9.43s/it]\u001b[A\n\n6it [00:46, 11.02s/it]\u001b[A\n\n7it [01:13, 15.72s/it]\u001b[A\n\n8it [01:25, 14.54s/it]\u001b[A\n\n9it [01:46, 16.63s/it]\u001b[A\n\n10it [02:03, 16.56s/it]\u001b[A\n\n                       \u001b[AMax diffs: [0.03108335 0.00316596 0.01145577 0.02595615 0.00625432 0.00457892\n 0.00308137 0.00171948 0.00111803 0.00153268]\n\n 11%|#1        | 1/9 [04:38<37:06, 278.33s/it]Iteration 1\n\n\n0it [00:00, ?it/s]\u001b[A\n\n1it [00:00,  5.57it/s]\u001b[A\n\n2it [00:00,  7.47it/s]\u001b[A\n\n4it [00:00,  9.98it/s]\u001b[A\n\n6it [00:00, 10.02it/s]\u001b[A\n\n8it [00:00,  8.35it/s]\u001b[A\n\n9it [00:01,  8.09it/s]\u001b[A\n\n10it [00:01,  7.60it/s]\u001b[A\n\n                       \u001b[AMax diffs: [5.5646896e-04 6.1869621e-05 1.8596649e-05 1.1374950e-03 3.2579899e-04\n 1.4414638e-04 1.4932826e-04 1.2412667e-04 6.6998415e-05 4.3699518e-05]\n\n 22%|##2       | 2/9 [06:54<22:44, 194.90s/it]Iteration 2\n\n\n0it [00:00, ?it/s]\u001b[A\n\n1it [00:00,  8.89it/s]\u001b[A\n\n3it [00:00, 10.52it/s]\u001b[A\n\n5it [00:00, 10.52it/s]\u001b[A\n\n7it [00:00, 10.73it/s]\u001b[A\n\n9it [00:00, 10.75it/s]\u001b[A\n\n                      \u001b[AMax diffs: [1.4066696e-05 6.9141388e-06 1.1444092e-05 8.8691711e-05 3.0869618e-05\n 2.3900066e-05 1.1682510e-05 9.5036812e-06 8.8969246e-06 6.9066882e-06]\n\n 22%|##2       | 2/9 [09:38<33:43, 289.07s/it]\nConverged: True at tolerance 0.001\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_cs <- function(alpha, coverage=0.95){\n  idx <- rev(order(alpha))\n  mass <- cumsum(alpha[idx])\n  last = which(mass >= coverage)[1]\n  cs <- idx[1:last]\n  return(list(cs=cs, alpha=alpha[cs], coverage = mass[last], target_coverage=coverage))\n}\n\ngseafit <- py$gseafit\nidx <- which(py$beta !=0)\nalpha <- py$gseafit$alpha\ncs <- purrr::map(1:nrow(alpha), ~compute_cs(alpha[.x,]))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# the first 4 components have evidence of association.\ngseafit$log_bfs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 140.0050049  27.9112549  11.7550116   3.5725992  -0.1652741  -0.1656251\n [7]  -0.1655889  -0.1655817  -0.1651826  -0.1653075\n```\n\n\n:::\n\n```{.r .cell-code}\n# the CSs fo the first 3 are singletons, \n# while the CS for th 4th component has 10 gene sets\npurrr::map_int(cs, ~length(.x$cs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]    1    1    1   10 4792 4792 4792 4792 4792 4792\n```\n\n\n:::\n\n```{.r .cell-code}\n# the PIP of the top SNP in each CS\npurrr::map_dbl(cs, ~.x$alpha[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1.000000000 1.000000000 0.999994278 0.760599554 0.008206210 0.008205083\n [7] 0.008204786 0.008204724 0.008205459 0.008206476\n```\n\n\n:::\n\n```{.r .cell-code}\n# check if the top snp is causal\npurrr::map_int(cs, ~.x$cs[1]) %in% idx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWe can see that each of the singleton CSs identify on of the \"active\" gene sets.\nThe 4th CS captures one of the two remaining effects. The SNP with the top PIP is the causal SNP.\nThe CSs corresponding to the other effects (L5-L10) are very large, containing thousands of GSs, and the maximum PIP is small ($< 0.1$). We also see the the log BF for the SER, which quantifies the evidence for any one SNP having an effect over the global null favor the null hypothesis. \n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check which CSs include which of the causal variables\nincidence <- do.call(rbind, purrr::map(1:10, ~as.integer(idx %in% cs[[.x]]$cs)))\nrownames(incidence) <- paste0('L', 1:nrow(incidence))\ncolnames(incidence) <- paste0('GS', 1:ncol(incidence))\nincidence\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    GS1 GS2 GS3 GS4 GS5\nL1    0   0   0   0   1\nL2    1   0   0   0   0\nL3    0   1   0   0   0\nL4    0   0   0   1   0\nL5    0   0   1   1   0\nL6    0   0   1   1   0\nL7    0   0   1   1   0\nL8    0   0   1   1   0\nL9    0   0   1   1   0\nL10   0   0   1   1   0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nWe compare the results against a marginal (on GS at a time) analysis, which is typical for GSEA.\nThe most direct comparison would be to the Baysian logistic regression with fixed prior variance.\n\nThe GS discovered in `L1-3` correspond to the three strongest marginal effects.\nHowever, we see that the GS captures in `L4` has the 16th strongest marginal effect.\nWe see that the causal GS that is not discovered in our analysis has the 144th strongest association, and a log BF of $\\approx 2.77$, corresponding to a BF of $\\approx 16$. Jeffreys proposed a threshold of $10$ for \"strong\" evidence, while Kass and Raftery later propose a treshold of $20$, so we will call this \"moderately-strong\" evidence of association. However, due to the multiple testing burden we judge it approporiate that this effect was not reported.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nmarginal_analysis <- with(py$marginal_results, tibble::tibble(\n  GS = colnames(c2$X),\n  i = 1:ncol(c2$X),\n  lbf=lbf,\n  effect=effect\n))\n\nmarginal_analysis %>%\n  mutate(causal = i %in% idx) %>%\n  arrange(desc(lbf)) %>%\n  mutate(rank = 1:n()) %>%\n  filter(causal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  GS        i       lbf    effect causal  rank\n  <chr> <int> <dbl[1d]> <dbl[1d]> <lgl>  <int>\n1 M8520  4347    146.        2.14 TRUE       1\n2 M2526   458     35.5       1.87 TRUE       2\n3 M847    487     20.9       2.24 TRUE       3\n4 M1092  3179     11.2       2.51 TRUE      16\n5 M4085  1661      2.77      1.26 TRUE     144\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\nWhich causal gene sets are driving the association of the 4-15th top marginal gene sets?\nThey all have substantial overlap with `M8520`, the top marginal enrichment.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmiddle_gene_sets <- marginal_analysis %>%\n  mutate(causal = i %in% idx) %>%\n  arrange(desc(lbf)) %>%\n  mutate(ran = 1:n()) %>%\n  head(15) %>% tail(12) %>%\n  {.$i}\n\nMatrix::t(c2$X[,middle_gene_sets]) %*% (c2$X[, idx])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n12 x 5 sparse Matrix of class \"dgCMatrix\"\n       M2526 M847 M4085 M1092 M8520\nM16010     3    2     1     .   121\nM2066      .    2     .     .    30\nM15664     .    1     .     .    97\nM18506     .    4     1     .    58\nM1037      .    1     .     .    43\nM34027     .    .     1     .    75\nM2368      5    7     1     .   154\nM5198      .    1     .     .    56\nM3766      .    1     .     .    93\nM2608      .    2     .     .    65\nM7357      1    1     2     .    50\nM10739     .    2     .     .    45\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\nIn this simulation, although the causal gene set are for genes upregulated in\nnon-small cell lung cancers, we see that there are gene sets associated with immune response, cell cycle, and a host of other cancers. The data show overwhelming support for the top effect.\nConditional on the first effect, the other gene sets are no longer predictive of inclusion in the list of genes provided. However, the extremely strong marginal enrichments in these other gene sets and cancer types would obscure this result.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarginal_analysis %>%\n  arrange(desc(lbf)) %>%\n  head(15) %>%\n  rename(geneSet = GS) %>%\n  left_join(select(c2$geneSetDes, c(geneSet, description))) %>%\n  select(c(geneSet, description, lbf))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(geneSet)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 3\n   geneSet description                                                       lbf\n   <chr>   <chr>                                                           <dbl>\n 1 M8520   Cluster 6 of method A: up-regulation of these genes in patient… 146. \n 2 M2526   Genes representing a co-expression network in atopic CD4 [Gene…  35.5\n 3 M847    Genes up-regulated in group C of tumors arising from overexpre…  20.9\n 4 M16010  Genes down-regulated in H1975 cells (non-small cell lung cance…  19.0\n 5 M2066   A list of known cell cycle regulated genes that was compiled f…  18.3\n 6 M15664  The 'Cervical Cancer Proliferation Cluster' (CCPC): genes whos…  17.4\n 7 M18506  Genes down-regulated in the ANBL-6 cell line (multiple myeloma…  16.2\n 8 M1037   Genes up-regulated in gastric cancer cell lines: doxorubicin […  15.1\n 9 M34027  Genes down-regulated on infection of normal human bronchial ep…  14.7\n10 M2368   Genes up-regulated during later stage of differentiation of Ol…  12.7\n11 M5198   Genes down-regulated in quiescent vs dividing CD34+ [GeneID=88…  12.6\n12 M3766   Up-regulated genes whose expression correlated with histologic…  12.5\n13 M2608   Cell cycle genes significantly (p =< 0.05) changed in fibrobla…  12.3\n14 M7357   Genes up-regulated at early stages of progenitor T lymphocyte …  12.0\n15 M10739  Genes down-regulated in ANBL-6 cell line (multiple myeloma, MM…  11.4\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}