[
  {
    "objectID": "notebooks/pbmcs/index.html",
    "href": "notebooks/pbmcs/index.html",
    "title": "2  Draft workflow",
    "section": "",
    "text": "2.1 Load and prepare data\nThe point of this document is to demonstrate the workflow of working with the gseasusie package.\nThe first section is specific to the data at hand– ultimately we will assume that the user can provide a list of interesting genes (“gene list”) and a list of background genes (“background”).\nThe second part exposes how the gseasusie package will ineract with the gibss Python package which implements logistic SuSiE. A critical piece of gseasusie and it’s documentation will be to guide users through setting up a pyton environment to run gibss.\nUltimately, we will want to report a list of credible sets + information about enriched gene sets + information about genes in enriched gene sets. We prototype a nested interactive table. It may also be good to develop some visualization tools.\nLoad the data\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# loads objects `deseq`, `de`, `genes`\nload('../../data/pbmc-purified/deseq2-pbmc-purified.RData')\nnames(deseq)\n\n[1] \"CD19+ B\"        \"CD56+ NK\"       \"T cell\"         \"CD14+ Monocyte\"\n[5] \"CD34+\"\nThe deseq results are a table where each row corresponds to a gene. This is just some light processing of these data. We add the celltype as a column, and add a column mapping Ensemble gene IDs to Entrez gene IDs.\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.5\n✔ ggplot2   3.5.1     ✔ stringr   1.5.1\n✔ lubridate 1.9.4     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n#' add columns for gene name and cell type to the deseq results\ncelltype &lt;- names(deseq)[[1]]\nadd_celltype &lt;- function(celltype){\n  deseq[[celltype]] %&gt;%\n    as.data.frame() %&gt;%\n    rownames_to_column(var = 'gene') %&gt;%\n    mutate(celltype = celltype)\n}\n\n# make big de table\nde &lt;- map_dfr(names(deseq), add_celltype)\n\nLoading required package: DESeq2\nLoading required package: S4Vectors\nLoading required package: stats4\nLoading required package: BiocGenerics\n\nAttaching package: 'BiocGenerics'\n\nThe following objects are masked from 'package:lubridate':\n\n    intersect, setdiff, union\n\nThe following objects are masked from 'package:dplyr':\n\n    combine, intersect, setdiff, union\n\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, saveRDS, setdiff,\n    table, tapply, union, unique, unsplit, which.max, which.min\n\n\nAttaching package: 'S4Vectors'\n\nThe following objects are masked from 'package:lubridate':\n\n    second, second&lt;-\n\nThe following object is masked from 'package:tidyr':\n\n    expand\n\nThe following objects are masked from 'package:dplyr':\n\n    first, rename\n\nThe following object is masked from 'package:utils':\n\n    findMatches\n\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n\nLoading required package: IRanges\n\nAttaching package: 'IRanges'\n\nThe following object is masked from 'package:lubridate':\n\n    %within%\n\nThe following object is masked from 'package:purrr':\n\n    reduce\n\nThe following objects are masked from 'package:dplyr':\n\n    collapse, desc, slice\n\nLoading required package: GenomicRanges\nLoading required package: GenomeInfoDb\nLoading required package: SummarizedExperiment\nLoading required package: MatrixGenerics\nLoading required package: matrixStats\n\nAttaching package: 'matrixStats'\n\nThe following object is masked from 'package:dplyr':\n\n    count\n\n\nAttaching package: 'MatrixGenerics'\n\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n\nLoading required package: Biobase\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n\n\nAttaching package: 'Biobase'\n\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n\n# gene label mapping\nhs &lt;- org.Hs.eg.db::org.Hs.eg.db\n\n\n\ngene_symbols &lt;- unique(de$gene)\nsymbol2entrez &lt;- AnnotationDbi::select(\n  hs, keys=gene_symbols,\n  columns=c('ENTREZID', 'ENSEMBL'),\n  keytype = 'ENSEMBL')\n\n'select()' returned 1:many mapping between keys and columns\n\n#' helper function to assign names to a list in a tidy pipeline\nadd_names = function(l, n){\n  names(l) &lt;- n\n  return(l)\n}\n\n# organize data into a list of tibbles, one for each cell type\ndata &lt;- de %&gt;%\n  dplyr::rename('ENSEMBL' = gene) %&gt;%\n  left_join(symbol2entrez, by='ENSEMBL') %&gt;%\n  relocate(ENTREZID, .after=ENSEMBL) %&gt;%\n  mutate(  # set default columns\n    beta = log2FoldChange,\n    se = lfcSE,\n    threshold.on = padj\n  ) %&gt;%\n  group_by(celltype) %&gt;%\n  group_map(~ .x, .keep = T) %&gt;%\n  add_names(map_chr(., ~pluck(.x, 'celltype')[1]))\n\nWarning in left_join(., symbol2entrez, by = \"ENSEMBL\"): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 78 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\nFrom here we can construct the gene list and background. We look at the CD19+B cells. We obtain a list of differentially expressed genes by including all genes with padj &lt; 1e-8 (5936/14929) genes.\nde &lt;- data$`CD19+ B` %&gt;%\n  filter(!is.na(ENTREZID)) %&gt;%\n  filter(!duplicated(ENTREZID))\n\n# get gene list and background\nlist &lt;- de %&gt;% filter(padj &lt; 1e-8) %&gt;% {.$ENTREZID}\nbackground &lt;- de$ENTREZID",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#running-gsea",
    "href": "notebooks/pbmcs/index.html#running-gsea",
    "title": "2  Draft workflow",
    "section": "2.2 Running GSEA",
    "text": "2.2 Running GSEA\nThe goal is to have a turn-key interface for performing GSEA with logistic SuSiE. The user should only need to provide a gene list list, a background set background, and the name of a gene set database (e.g. `GO Biological Processes’).\n\n2.2.1 Working with python\nkarltayeb/gibss is a python package implementing logistic SuSiE. We assume access to a virtual environment with gibss installed.\n\nlibrary(reticulate)\nuse_virtualenv('gibss')\n\nHere is a light wrapper for gibss.logistic_sparse.fit_logistic_susie2 which is a fast implementation of logistic SuSiE which can exploit the sparsity of the gene to gene-set map.\n\nimport numpy as np\nfrom scipy import sparse\nfrom gibss.logistic_sparse import fit_logistic_susie2\nfrom jax.tree_util import tree_map\n\ndef logistic_susie_gsea(X, y):\n  X_sp = sparse.csr_matrix(X)\n  y = np.array(y)\n  fit = fit_logistic_susie2(X_sp, y, L=10, maxiter=50, tol=1e-6)\n  fit2 = fit._asdict()\n  return fit2\n\n\n\n2.2.2 Handling gene sets\nThere are a number of packages and resources for getting gene sets. These data typically arrive as a table where each row corresponds to a (gene set, gene) pair. All we need to do is filter down to the background genes and then convert this table into a binary gene set by gene membership matrix X. Then we take the gene list and construct a binary response y.\n\n#' Construct gene set matrix out of gene set table\n#' @param tbl a tibble that has at least two columns: `geneSet` and `gene`\n#' @returns a sparse gene_set x genes membership matrix where\n#'          gene set and gene names stored in `colnames` and `rownames` respectively.\nconstruct_geneset_matrix &lt;- function(db){\n  tbl &lt;- db %&gt;%\n    mutate(geneSetIdx = vctrs::vec_group_id(geneSet),\n           geneIdx = vctrs::vec_group_id(gene))\n  geneMapping &lt;- tbl %&gt;%\n    dplyr::select(c(gene, geneIdx)) %&gt;%\n    unique()\n  geneSetMapping &lt;- tbl %&gt;%\n    dplyr::select(c(geneSet, geneSetIdx)) %&gt;%\n    unique()\n  X &lt;- tbl %&gt;%\n    {Matrix::sparseMatrix(.$geneIdx, .$geneSetIdx, x=1.)} %&gt;%\n    Matrix::t()\n  rownames(X) &lt;- geneSetMapping$geneSet\n  colnames(X) &lt;- geneMapping$gene\n  return(list(X=X, geneSetMapping=geneSetMapping, geneMapping=geneMapping, geneSets=tbl))\n}\n\n#' make X and y for logistic SuSiE\nprepare_data &lt;- function(list, background, db){\n  # get genes included in analysis, record which are excluded\n  genes_in_analysis &lt;- intersect(background, unique(db$gene))\n  genes_excluded &lt;- setdiff(background, genes_in_analysis)\n  \n  # construct X\n  X &lt;- db %&gt;%\n    dplyr::filter(gene %in% genes_in_analysis) %&gt;%\n    construct_geneset_matrix()\n  X$geneSets &lt;- X$geneSets %&gt;% \n    mutate(geneInList = gene %in% list)\n  # construct y\n  y &lt;- as.numeric(colnames(X$X) %in% list)\n  return(c(X, list(y=y, included = genes_in_analysis, excluded=genes_excluded)))\n}\n\n\n\n2.2.3 Running the GSEA\nWith the functions defined above we can run our GSEA analysis with a few lines of code in just a few seconds.\n\n# here is an example of how to get gene sets from WebGestaltR\n#' Fit logistic SuSiE using gene sets available from WebGestaltR\n#' @param list a list of interesting genes\n#' @param background a list of background genes\n#' @param enrichDatabase a database of genesets available in `WebGestaltR`, see `WebGestaltR::listGeneSet()`\n#' @returns a list with three items `$fit` `$data` and `$time`. \nfit_gsea_susie_webgestalt &lt;- function(list, backgrround, enrichDatabase = 'geneontology_Biological_Process'){\n  gsdb &lt;- WebGestaltR::loadGeneSet(enrichDatabase = enrichDatabase)\n\n  time &lt;- tictoc::tic('Finding complementary enrichments in GO-BP...')\n  fit &lt;- gsdb$geneSet %&gt;%\n    prepare_data(list, background, .) %&gt;%\n    {list(fit=py$logistic_susie_gsea(.$X, .$y), data=.)}\n  tictoc::toc()\n  fit$time &lt;- time\n  fit$data$X &lt;- NULL\n  return(fit)\n}\n\nfit &lt;- fit_gsea_susie_webgestalt(list, background, 'geneontology_Biological_Process')\n\nFinding complementary enrichments in GO-BP...: 11.933 sec elapsed",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#summarizing-output",
    "href": "notebooks/pbmcs/index.html#summarizing-output",
    "title": "2  Draft workflow",
    "section": "2.3 Summarizing output",
    "text": "2.3 Summarizing output\nAlthough logistic_susie_gsea is a python function, all it’s output is of a standard type that can be handled with reticulate’s automatic type conversions. We can work with the result like a pure R object.\n\n# confirm that we can save/load as an RDS\nsaveRDS(fit, 'test.rds')\nfit &lt;- readRDS('test.rds')\n\nHere we organize the component, gene-set, and gene level information into a nested dataframe that can be drilled into by users. This is a draft, the information provided at each level should be considered.\n\nmake_cs_tbl_single &lt;- function(fit, l){\n  cs &lt;- fit$fit$credible_sets[[l]]\n  tidyr::as_tibble(cs) %&gt;%\n    mutate(\n      geneSetIdx = cs - 1, \n      cs = paste0('L', l),\n      lbf_ser = fit$fit$lbf_ser[[l]]\n    )\n}\n\nmake_cs_tbl &lt;- function(fit, min_lbf_ser=log(10.)){\n  # include components with large enough lbf_ser\n  include_components &lt;- which(fit$fit$lbf_ser &gt; min_lbf_ser)\n  purrr::map_dfr(include_components, ~make_cs_tbl_single(fit, .x))\n}\n\ncs_tbl &lt;- make_cs_tbl(fit, 1.)\n\n#' organize gene level details\narrange_details &lt;- function(tbl){\n  tbl %&gt;% \n    group_by(geneSet) %&gt;%\n    mutate(geneSetSize = n(), propInList = mean(geneInList)) %&gt;%\n    ungroup() %&gt;%\n    select(c(geneSet, alpha, description, geneSetSize, propInList, gene, geneInList)) %&gt;%\n    nest(.by = c(geneSet, alpha, description, geneSetSize, propInList))\n}\n\n# make nested table: components -&gt; geneSets -&gt; genes\ncs_tbl_nested &lt;- cs_tbl %&gt;%\n  left_join(fit$data$geneSets) %&gt;%\n  nest(.by= c(cs, size, coverage, target_coverage, lbf_ser)) %&gt;%\n  rowwise() %&gt;%\n  mutate(data = list(arrange_details(data)))\n\nJoining with `by = join_by(geneSetIdx)`\n\n\n\nlibrary(reactable)\nmake_get_details &lt;- function(tbl){\n  if('data' %in% names(tbl)){\n    get_details &lt;- function(index){\n      deets &lt;- tbl[index,]\n      htmltools::div(style = \"padding: 1rem\",\n        reactable(\n          dplyr::select(deets$data[[1]], -any_of('data')),\n          details = make_get_details(deets$data[[1]]),\n          outlined = TRUE,\n          defaultColDef = colDef(format=colFormat(digits=3))\n        )\n      )\n    }\n  } else{\n    get_details &lt;- NULL\n  }\n  return(get_details)\n}\nreactable(\n  select(cs_tbl_nested, -any_of('data')),\n  details = make_get_details(cs_tbl_nested),\n  defaultColDef = colDef(format=colFormat(digits=3))\n)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#in-the-gseasusie-package",
    "href": "notebooks/pbmcs/index.html#in-the-gseasusie-package",
    "title": "2  Draft workflow",
    "section": "2.4 In the gseasusie package",
    "text": "2.4 In the gseasusie package\nThe functions above have been added to the gseasusie package.\n\n#devtools::install_local('~/R/gseasusie/', force=T)\nfit &lt;- gseasusie::fit_gsea_susie_webgestalt(list, background, 'geneontology_Biological_Process')\n\nFinding complementary enrichments in GO-BP...: 11.65 sec elapsed\n\n\n\nenrichDatabase = 'geneontology_Biological_Process_noRedundant'\n\ndb &lt;- WebGestaltR::loadGeneSet(enrichDatabase = enrichDatabase)\n\nfit2$credible_sets\nfit2$lbf_ser\n\n\nconvertGeneSet &lt;- function(geneSet, min.size = 1){\n  geneSet %&gt;%\n    dplyr::select(geneSet, gene) %&gt;%\n    dplyr::group_by(geneSet) %&gt;%\n    dplyr::filter(dplyr::n() &gt;= min.size) %&gt;%\n    tidyr::chop(gene) %&gt;% dplyr::ungroup() %&gt;%\n    gseasusie:::tibble2namedlist()\n}\n\n# load gobp\ngobp &lt;- gseasusie:::load.webGestalt.geneSet(\n  'geneontology_Biological_Process')\n# X is a gene set x gene matrix. X_ij = 1 if gene j belongs to GS i\nX &lt;- gobp$geneSet %&gt;%\n  filter(gene %in% background) %&gt;%\n  dplyr::select(gene, geneSet) %&gt;%\n  convertGeneSet(min.size = 1) %&gt;% # convert tibble to named list geneset: {genes}\n  gseasusie:::geneSet2X() %&gt;% # convert named list to a binary matrix\n  Matrix::t() # for SuSiE we need gene sets x genes.\n\ny &lt;- as.integer(colnames(X) %in% list)\n\n\nfit_logistic_susie &lt;- function(X, y){\n  gibss &lt;- reticulate::import('gibss')\n  np &lt;- reticulate::import('numpy')\n  fit = gibss$logistic$fit_logistic_susie2(X, np$array(y), L=10L, maxiter=20L)\n  ser = gibss$logistic$fit_logistic_susie2(X, np$array(y), L=1L, maxiter=1L)\n  return(list(fit=fit, ser=ser))\n}\ntictoc::tic()\nfit &lt;- fit_logistic_susie(X, y)\ntictoc::toc()\n\nimport pickle\nfit = r.fit\npickle.dump(fit, open('cd19b_gobp.pkl', 'wb'))\nfit2 = pickle.load(open('cd19b_gobp.pkl', 'rb'))\n\n\ncd19_gobp_fit &lt;- py$fit2\nfit &lt;- cd19_gobp_fit$fit\nser &lt;- cd19_gobp_fit$ser\n\ncs_tbl &lt;- purrr::map_dfr(1:10, ~list(\n  cs=list(fit$credible_sets[[.x]]$cs + 1), \n  alpha = list(fit$credible_sets[[.x]]$alpha),\n  lbf_ser = fit$lbf_ser[.x],\n  size = fit$credible_sets[[.x]]$size)) %&gt;%\n  mutate(component = purrr::map_chr(1:n(), ~glue::glue('L{.x}'))) %&gt;%\n  filter(lbf_ser &gt; 1, size &lt; 100) %&gt;%\n  tidyr::unnest_longer(c(cs, alpha)) %&gt;%\n  mutate(geneSet = rownames(X)[cs]) %&gt;%\n  left_join(gobp$geneSetDes) %&gt;%\n  arrange(component)\n\ncs_tbl\n\n\n# write list to file, one line per gene\ntibble(gene = list) %&gt;%\n  write_csv('cd19b_de_genes.txt', col_names=F)\n\ntibble(gene=background) %&gt;%\n  write_csv('cd19_background.txt', col_names=F)\n\n\n2.4.0.1 WeGestaltR\nWebGestaltR has a really robust geneID mapping, or at least more\n\n# install.packages('WebGestaltR')\nidmap &lt;- WebGestaltR::idMapping(inputGene=background, sourceIdType=\"entrezgene\", targetIdType = \"genesymbol\")\nidmap\n\n\nlibrary(enrichR)\nsetEnrichrSite(\"EnrichR\")\ndbs &lt;- listEnrichrDbs()\n\n\nimport_gsea_fun &lt;- function() {\n  reticulate::py_run_string(\"\nimport numpy as np\nfrom scipy import sparse\nfrom gibss.logistic_sparse import fit_logistic_susie2\ndef logistic_susie_gsea(X, y):\n    X_sp = sparse.csr_matrix(X)\n    y = np.array(y)\n    fit = fit_logistic_susie2(X_sp, y, L=10, maxiter=50, tol=1e-6)\n    fit2 = fit._asdict()\n    return fit2\nlogistic_susie_gsea\")$logistic_susie_gsea\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  }
]