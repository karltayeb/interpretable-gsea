[
  {
    "objectID": "notebooks/pbmcs/index.html",
    "href": "notebooks/pbmcs/index.html",
    "title": "2  PBMC GSEA Example",
    "section": "",
    "text": "2.1 Running logistic SuSiE on the PBMC data\nsource('notebooks/pbmcs/functions.R')\nreticulate::use_virtualenv('gibss')\ndata &lt;- prep_pbmc_data()\n#' function for getting the gene set data\nload_regression_data &lt;- function(data, celltype, quantile, db_name){\n  db &lt;- WebGestaltR::loadGeneSet(enrichDatabase = db_name)\n  data %&gt;%\n    make_gene_list(celltype, q) %&gt;%\n    gseasusie:::prepare_data()\n}\n\n#' driver function for running logistic SuSiE on pbmc data + webgestalt gene sets\ndriver &lt;- function(celltype, q, db, path){\n  print(\"I'm driving here!\")\n  data %&gt;%\n    make_gene_list(celltype, q) %&gt;%\n    {gseasusie::fit_gsea_susie_webgestalt(\n      .$gene_list, \n      .$gene_background, \n      db,\n      tol=1e-5,\n      maxiter=100,\n      alpha=0.5,\n      gamma=0.0\n    )} %&gt;%\n    save_model(path=path)\n  return(T)\n}\nHere is an example of how to use the driver function.\n# the driver function fits the model and saves it, just returns true\ndriver(\n  'CD14+ Monocyte', \n  0.1, \n  'geneontology_Biological_Process',\n  'notebooks/pbmcs/results/cd14plusmonocyte/geneontology_Biological_Process/q=0.1.rds'\n)\n# load the results. Contains $fit, $data, $time\nres &lt;- readRDS('notebooks/pbmcs/results/cd14plusmonocyte/geneontology_Biological_Process/q=0.1.rds')\nNow we run logistic SuSiE using the top 10% of genes in each celltype. We rerun the analysis for the gene ontology subsets available through the WebGestaltR package. WebGestaltR offers various subsets of the GO, e.g. geneontology_Biological_Process, and an abridged version geneontology_Biological_Process_noRedundant.\ncelltypes &lt;- names(data)\ncelltypes_sanitized &lt;- c('cd14plusmonocyte', 'cd19plusb', 'cd34plus', 'cd56plusnk', 'tcell')\nquantiles &lt;- c(0.1)\ndb &lt;- c(\n  'geneontology_Biological_Process', \n  'geneontology_Biological_Process_noRedundant', \n  'geneontology_Cellular_Component', \n  'geneontology_Cellular_Component_noRedundant', \n  'geneontology_Molecular_Function', \n  'geneontology_Molecular_Function_noRedundant'\n)\n\nconfig &lt;- tidyr::crossing(\n  tibble(celltype = celltypes, celltype_sanitized=celltypes_sanitized),\n  q=quantiles,\n  db = db\n)\nmake_path &lt;- function(celltype_sanitized, db, q){\n  glue::glue('notebooks/pbmcs/results/{celltype_sanitized}/{db}/q={q}.rds')\n}\n\nconfig %&gt;%\n  dplyr::rowwise() %&gt;%\n  dplyr::mutate(path = make_path(celltype_sanitized, db, q)) %&gt;%\n  dplyr::mutate(run=driver(celltype, q, db, path))\nmake_cs_tbl_single &lt;- function(fit, l){\n  cs &lt;- fit$fit$credible_sets[[l]]\n  tidyr::as_tibble(cs) %&gt;%\n    dplyr::mutate(\n      geneSetIdx = cs + 1, \n      component = paste0('L', l),\n      lbf_ser = fit$fit$lbf_ser[[l]]\n    ) %&gt;%\n    dplyr::select(-cs) %&gt;%\n    dplyr::left_join(fit$data$geneSets) %&gt;%\n    dplyr::group_by(component, geneSet) %&gt;%\n    dplyr::mutate(\n      geneSetSize = n(),\n      propInList = mean(geneInList)\n    ) %&gt;%\n    dplyr::ungroup()\n}\n\nmake_cs_tbl &lt;- function(fit, min_lbf_ser=log(10.)){\n  # include components with large enough lbf_ser\n  include_components &lt;- which(fit$fit$lbf_ser &gt; min_lbf_ser)\n  purrr::map_dfr(include_components, ~make_cs_tbl_single(fit, .x))\n}\n\nmake_component_tbl_single &lt;- function(fit, l){\n  # component, gene set, alpha, beta, lbf, prior_variance\n  with(fit$fit, tibble(\n    component=glue::glue('L{l}'), \n    geneSet = fit$data$geneSetMapping$geneSet, \n    alpha=alpha[l,],\n    beta=beta[l,], \n    lbf=lbf[l,], \n    prior_variance=prior_variance[l]))\n}\n\nmake_component_tbl &lt;- function(fit, min_lbf_ser = log(10)){\n  include_components &lt;- which(fit$fit$lbf_ser &gt; min_lbf_ser)\n  purrr::map_dfr(include_components, ~make_component_tbl_single(fit, .x))\n}\ndb = 'geneontology_Biological_Process'\nq = 0.1\ncelltype = 'CD19+ B'\ncelltypes_sanitized_list &lt;- as.list(celltypes_sanitized)\nnames(celltypes_sanitized_list) &lt;- celltype\n\nload_model &lt;- function(celltype, q, db){\n  # load fit model\n  path &lt;- glue::glue('notebooks/pbmcs/results/{celltypes_sanitized_list[[celltype]]}/{db}/q={q}.rds')\n  message(glue::glue('loading fit from: {path}'))\n  fit &lt;- readRDS(path)\n  return(fit)\n}\n\nload_model2 &lt;- function(path){\n  # load fit model\n  message(glue::glue('loading fit from: {path}'))\n  fit &lt;- readRDS(path)\n  return(fit)\n}\n\nmake_cs_tbl_nested &lt;- function(fit){\n  more_go_info &lt;- AnnotationDbi::select(GO.db::GO.db,\n         keys = unique(fit$data$geneSets$geneSet),\n         columns = c('TERM', 'DEFINITION'),\n         keytype = 'GOID') %&gt;% \n    as_tibble() %&gt;%\n    dplyr::mutate(geneSet=GOID)\n  \n  more_gene_info &lt;- AnnotationDbi::select(org.Hs.eg.db::org.Hs.eg.db,\n        keys = unique(fit$data$geneMapping$gene),\n        columns = c('SYMBOL', 'GENETYPE', 'GENENAME'),\n        keytype = 'ENTREZID') %&gt;%\n    as_tibble() %&gt;%\n    dplyr::mutate(gene = ENTREZID)\n  \n  gene_columns &lt;- c('ENTREZID', 'SYMBOL', 'GENENAME', 'geneInList')\n  gene_set_columns &lt;- c('geneSet', 'TERM', 'DEFINITION', 'alpha', 'beta', 'lbf', 'geneSetSize', 'propInList')\n  component_columns &lt;- c('component', 'size', 'coverage', 'target_coverage', 'lbf_ser', 'prior_variance')\n  \n  all_columns &lt;- c(component_columns, gene_set_columns, gene_columns)\n  \n  message('building nested credible set table')\n  fit %&gt;%\n    make_cs_tbl() %&gt;%\n    left_join(make_component_tbl(fit)) %&gt;% # add effect estimates, etc.\n    left_join(more_go_info) %&gt;%\n    left_join(more_gene_info) %&gt;%\n    dplyr::select(all_columns) %&gt;%\n    # nest gene level data\n    nest(.by= c(component_columns, gene_set_columns), .key='details') %&gt;%\n    # nest gene set level data\n    nest(.by= component_columns, .key='details')\n}\n\ncs_tbl_nested &lt;- load_model(celltype, q, db) %&gt;% \n  make_cs_tbl_nested()\nnested_summary &lt;- config %&gt;%\n  dplyr::rowwise() %&gt;%\n  dplyr::mutate(path = make_path(celltype_sanitized, db, q)) %&gt;%\n  ungroup() %&gt;%\n  dplyr::mutate(nested_table = purrr::map(path, ~make_cs_tbl_nested(readRDS(.x))))\nnested_summary %&gt;%\n  saveRDS('notebooks/pbmcs/results/nested_table.rds')",
    "crumbs": [
      "PBMC example",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>PBMC GSEA Example</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#running-gsea",
    "href": "notebooks/pbmcs/index.html#running-gsea",
    "title": "2  Draft workflow",
    "section": "2.2 Running GSEA",
    "text": "2.2 Running GSEA\nThe goal is to have a turn-key interface for performing GSEA with logistic SuSiE. The user should only need to provide a gene list list, a background set background, and the name of a gene set database (e.g. `GO Biological Processes’).\n\n2.2.1 Working with python\nkarltayeb/gibss is a python package implementing logistic SuSiE. We assume access to a virtual environment with gibss installed.\n\nlibrary(reticulate)\nuse_virtualenv('gibss')\n\nHere is a light wrapper for gibss.logistic_sparse.fit_logistic_susie2 which is a fast implementation of logistic SuSiE which can exploit the sparsity of the gene to gene-set map.\n\nimport numpy as np\nfrom scipy import sparse\nfrom gibss.logistic_sparse import fit_logistic_susie2\nfrom jax.tree_util import tree_map\n\ndef logistic_susie_gsea(X, y):\n  X_sp = sparse.csr_matrix(X)\n  y = np.array(y)\n  fit = fit_logistic_susie2(X_sp, y, L=10, maxiter=50, tol=1e-6)\n  fit2 = fit._asdict()\n  return fit2\n\n\n\n2.2.2 Handling gene sets\nThere are a number of packages and resources for getting gene sets. These data typically arrive as a table where each row corresponds to a (gene set, gene) pair. All we need to do is filter down to the background genes and then convert this table into a binary gene set by gene membership matrix X. Then we take the gene list and construct a binary response y.\n\n#' Construct gene set matrix out of gene set table\n#' @param tbl a tibble that has at least two columns: `geneSet` and `gene`\n#' @returns a sparse gene_set x genes membership matrix where\n#'          gene set and gene names stored in `colnames` and `rownames` respectively.\nconstruct_geneset_matrix &lt;- function(db){\n  tbl &lt;- db %&gt;%\n    mutate(geneSetIdx = vctrs::vec_group_id(geneSet),\n           geneIdx = vctrs::vec_group_id(gene))\n  geneMapping &lt;- tbl %&gt;%\n    dplyr::select(c(gene, geneIdx)) %&gt;%\n    unique()\n  geneSetMapping &lt;- tbl %&gt;%\n    dplyr::select(c(geneSet, geneSetIdx)) %&gt;%\n    unique()\n  X &lt;- tbl %&gt;%\n    {Matrix::sparseMatrix(.$geneIdx, .$geneSetIdx, x=1.)} %&gt;%\n    Matrix::t()\n  rownames(X) &lt;- geneSetMapping$geneSet\n  colnames(X) &lt;- geneMapping$gene\n  return(list(X=X, geneSetMapping=geneSetMapping, geneMapping=geneMapping, geneSets=tbl))\n}\n\n#' make X and y for logistic SuSiE\nprepare_data &lt;- function(list, background, db){\n  # get genes included in analysis, record which are excluded\n  genes_in_analysis &lt;- intersect(background, unique(db$gene))\n  genes_excluded &lt;- setdiff(background, genes_in_analysis)\n  \n  # construct X\n  X &lt;- db %&gt;%\n    dplyr::filter(gene %in% genes_in_analysis) %&gt;%\n    construct_geneset_matrix()\n  X$geneSets &lt;- X$geneSets %&gt;% \n    mutate(geneInList = gene %in% list)\n  # construct y\n  y &lt;- as.numeric(colnames(X$X) %in% list)\n  return(c(X, list(y=y, included = genes_in_analysis, excluded=genes_excluded)))\n}\n\n\n\n2.2.3 Running the GSEA\nWith the functions defined above we can run our GSEA analysis with a few lines of code in just a few seconds.\n\n# here is an example of how to get gene sets from WebGestaltR\n#' Fit logistic SuSiE using gene sets available from WebGestaltR\n#' @param list a list of interesting genes\n#' @param background a list of background genes\n#' @param enrichDatabase a database of genesets available in `WebGestaltR`, see `WebGestaltR::listGeneSet()`\n#' @returns a list with three items `$fit` `$data` and `$time`. \nfit_gsea_susie_webgestalt &lt;- function(list, backgrround, enrichDatabase = 'geneontology_Biological_Process'){\n  gsdb &lt;- WebGestaltR::loadGeneSet(enrichDatabase = enrichDatabase)\n\n  time &lt;- tictoc::tic('Finding complementary enrichments in GO-BP...')\n  fit &lt;- gsdb$geneSet %&gt;%\n    prepare_data(list, background, .) %&gt;%\n    {list(fit=py$logistic_susie_gsea(.$X, .$y), data=.)}\n  tictoc::toc()\n  fit$time &lt;- time\n  fit$data$X &lt;- NULL\n  return(fit)\n}\n\nfit &lt;- fit_gsea_susie_webgestalt(list, background, 'geneontology_Biological_Process')\n\nFinding complementary enrichments in GO-BP...: 11.948 sec elapsed",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#summarizing-output",
    "href": "notebooks/pbmcs/index.html#summarizing-output",
    "title": "2  Draft workflow",
    "section": "2.3 Summarizing output",
    "text": "2.3 Summarizing output\nAlthough logistic_susie_gsea is a python function, all it’s output is of a standard type that can be handled with reticulate’s automatic type conversions. We can work with the result like a pure R object.\n\n# confirm that we can save/load as an RDS\nsaveRDS(fit, 'test.rds')\nfit &lt;- readRDS('test.rds')\n\nHere we organize the component, gene-set, and gene level information into a nested dataframe that can be drilled into by users. This is a draft, the information provided at each level should be considered.\n\nmake_cs_tbl_single &lt;- function(fit, l){\n  cs &lt;- fit$fit$credible_sets[[l]]\n  tidyr::as_tibble(cs) %&gt;%\n    mutate(\n      geneSetIdx = cs - 1, \n      cs = paste0('L', l),\n      lbf_ser = fit$fit$lbf_ser[[l]]\n    )\n}\n\nmake_cs_tbl &lt;- function(fit, min_lbf_ser=log(10.)){\n  # include components with large enough lbf_ser\n  include_components &lt;- which(fit$fit$lbf_ser &gt; min_lbf_ser)\n  purrr::map_dfr(include_components, ~make_cs_tbl_single(fit, .x))\n}\n\ncs_tbl &lt;- make_cs_tbl(fit, 1.)\n\n#' organize gene level details\narrange_details &lt;- function(tbl){\n  tbl %&gt;% \n    group_by(geneSet) %&gt;%\n    mutate(geneSetSize = n(), propInList = mean(geneInList)) %&gt;%\n    ungroup() %&gt;%\n    select(c(geneSet, alpha, description, geneSetSize, propInList, gene, geneInList)) %&gt;%\n    nest(.by = c(geneSet, alpha, description, geneSetSize, propInList))\n}\n\n# make nested table: components -&gt; geneSets -&gt; genes\ncs_tbl_nested &lt;- cs_tbl %&gt;%\n  left_join(fit$data$geneSets) %&gt;%\n  nest(.by= c(cs, size, coverage, target_coverage, lbf_ser)) %&gt;%\n  rowwise() %&gt;%\n  mutate(data = list(arrange_details(data)))\n\nJoining with `by = join_by(geneSetIdx)`\n\n\n\nlibrary(reactable)\nmake_get_details &lt;- function(tbl){\n  if('data' %in% names(tbl)){\n    get_details &lt;- function(index){\n      deets &lt;- tbl[index,]\n      htmltools::div(style = \"padding: 1rem\",\n        reactable(\n          dplyr::select(deets$data[[1]], -any_of('data')),\n          details = make_get_details(deets$data[[1]]),\n          outlined = TRUE,\n          defaultColDef = colDef(format=colFormat(digits=3))\n        )\n      )\n    }\n  } else{\n    get_details &lt;- NULL\n  }\n  return(get_details)\n}\nreactable(\n  select(cs_tbl_nested, -any_of('data')),\n  details = make_get_details(cs_tbl_nested),\n  defaultColDef = colDef(format=colFormat(digits=3))\n)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#in-the-gseasusie-package",
    "href": "notebooks/pbmcs/index.html#in-the-gseasusie-package",
    "title": "2  Draft workflow",
    "section": "2.4 In the gseasusie package",
    "text": "2.4 In the gseasusie package\nThe functions above have been added to the gseasusie package.\n\n#devtools::install_local('~/R/gseasusie/', force=T)\nfit &lt;- gseasusie::fit_gsea_susie_webgestalt(list, background, 'geneontology_Biological_Process')\n\nFinding complementary enrichments in GO-BP...: 11.577 sec elapsed\n\n\n\nenrichDatabase = 'geneontology_Biological_Process_noRedundant'\n\ndb &lt;- WebGestaltR::loadGeneSet(enrichDatabase = enrichDatabase)\n\nfit2$credible_sets\nfit2$lbf_ser\n\n\nconvertGeneSet &lt;- function(geneSet, min.size = 1){\n  geneSet %&gt;%\n    dplyr::select(geneSet, gene) %&gt;%\n    dplyr::group_by(geneSet) %&gt;%\n    dplyr::filter(dplyr::n() &gt;= min.size) %&gt;%\n    tidyr::chop(gene) %&gt;% dplyr::ungroup() %&gt;%\n    gseasusie:::tibble2namedlist()\n}\n\n# load gobp\ngobp &lt;- gseasusie:::load.webGestalt.geneSet(\n  'geneontology_Biological_Process')\n# X is a gene set x gene matrix. X_ij = 1 if gene j belongs to GS i\nX &lt;- gobp$geneSet %&gt;%\n  filter(gene %in% background) %&gt;%\n  dplyr::select(gene, geneSet) %&gt;%\n  convertGeneSet(min.size = 1) %&gt;% # convert tibble to named list geneset: {genes}\n  gseasusie:::geneSet2X() %&gt;% # convert named list to a binary matrix\n  Matrix::t() # for SuSiE we need gene sets x genes.\n\ny &lt;- as.integer(colnames(X) %in% list)\n\n\nfit_logistic_susie &lt;- function(X, y){\n  gibss &lt;- reticulate::import('gibss')\n  np &lt;- reticulate::import('numpy')\n  fit = gibss$logistic$fit_logistic_susie2(X, np$array(y), L=10L, maxiter=20L)\n  ser = gibss$logistic$fit_logistic_susie2(X, np$array(y), L=1L, maxiter=1L)\n  return(list(fit=fit, ser=ser))\n}\ntictoc::tic()\nfit &lt;- fit_logistic_susie(X, y)\ntictoc::toc()\n\nimport pickle\nfit = r.fit\npickle.dump(fit, open('cd19b_gobp.pkl', 'wb'))\nfit2 = pickle.load(open('cd19b_gobp.pkl', 'rb'))\n\n\ncd19_gobp_fit &lt;- py$fit2\nfit &lt;- cd19_gobp_fit$fit\nser &lt;- cd19_gobp_fit$ser\n\ncs_tbl &lt;- purrr::map_dfr(1:10, ~list(\n  cs=list(fit$credible_sets[[.x]]$cs + 1), \n  alpha = list(fit$credible_sets[[.x]]$alpha),\n  lbf_ser = fit$lbf_ser[.x],\n  size = fit$credible_sets[[.x]]$size)) %&gt;%\n  mutate(component = purrr::map_chr(1:n(), ~glue::glue('L{.x}'))) %&gt;%\n  filter(lbf_ser &gt; 1, size &lt; 100) %&gt;%\n  tidyr::unnest_longer(c(cs, alpha)) %&gt;%\n  mutate(geneSet = rownames(X)[cs]) %&gt;%\n  left_join(gobp$geneSetDes) %&gt;%\n  arrange(component)\n\ncs_tbl\n\n\n# write list to file, one line per gene\ntibble(gene = list) %&gt;%\n  write_csv('cd19b_de_genes.txt', col_names=F)\n\ntibble(gene=background) %&gt;%\n  write_csv('cd19_background.txt', col_names=F)\n\n\n2.4.0.1 WeGestaltR\nWebGestaltR has a really robust geneID mapping, or at least more\n\n# install.packages('WebGestaltR')\nidmap &lt;- WebGestaltR::idMapping(inputGene=background, sourceIdType=\"entrezgene\", targetIdType = \"genesymbol\")\nidmap\n\n\nlibrary(enrichR)\nsetEnrichrSite(\"EnrichR\")\ndbs &lt;- listEnrichrDbs()\n\n\nimport_gsea_fun &lt;- function() {\n  reticulate::py_run_string(\"\nimport numpy as np\nfrom scipy import sparse\nfrom gibss.logistic_sparse import fit_logistic_susie2\ndef logistic_susie_gsea(X, y):\n    X_sp = sparse.csr_matrix(X)\n    y = np.array(y)\n    fit = fit_logistic_susie2(X_sp, y, L=10, maxiter=50, tol=1e-6)\n    fit2 = fit._asdict()\n    return fit2\nlogistic_susie_gsea\")$logistic_susie_gsea\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Draft workflow</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/index.html#a-table-of-pbmc-results-on-go",
    "href": "notebooks/pbmcs/index.html#a-table-of-pbmc-results-on-go",
    "title": "2  PBMC GSEA Example",
    "section": "2.2 A table of PBMC results on GO",
    "text": "2.2 A table of PBMC results on GO\n\nsource('notebooks/pbmcs/functions.R')\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata &lt;- readRDS('notebooks/pbmcs/results/nested_table.rds') %&gt;%\n  dplyr::select(-path) %&gt;%\n  dplyr::rename(details = nested_table)\n\n\nreactable(\n  dplyr::select(data, -c(celltype_sanitized, details)),\n  details = make_get_details(data))",
    "crumbs": [
      "PBMC example",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>PBMC GSEA Example</span>"
    ]
  },
  {
    "objectID": "notebooks/summary.html",
    "href": "notebooks/summary.html",
    "title": "3  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/table.html",
    "href": "notebooks/pbmcs/table.html",
    "title": "3  PBMC GSEA Table",
    "section": "",
    "text": "3.1 A table of PBMC results on GO\nIn order to present the GSEA results in a more digestable format we take the SuSiE output and put it into a nested table that can be viewed conveniently in the browser. For each experiment (gene list + gene set database) the table has three levels.\nsource('notebooks/pbmcs/functions.R')\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata &lt;- readRDS('notebooks/pbmcs/results/nested_table.rds') %&gt;%\n  dplyr::select(-path) %&gt;%\n  dplyr::rename(details = nested_table)\n\n\nreactable(\n  dplyr::select(data, -c(celltype_sanitized, details)),\n  details = make_get_details(data))",
    "crumbs": [
      "PBMC example",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>PBMC GSEA Table</span>"
    ]
  },
  {
    "objectID": "notebooks/pbmcs/table.html#a-table-of-pbmc-results-on-go",
    "href": "notebooks/pbmcs/table.html#a-table-of-pbmc-results-on-go",
    "title": "3  PBMC GSEA Table",
    "section": "",
    "text": "The top level has information about each component of the model.\nThe second level reports information on the top gene sets in the the components (the 95% credible set)\nThe third level reports information on the genes in each gene set.",
    "crumbs": [
      "PBMC example",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>PBMC GSEA Table</span>"
    ]
  }
]